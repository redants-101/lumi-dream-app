# ⚠️ 用户层级显示闪烁问题

## 🚨 问题描述

**症状**：Basic 用户登录后，页面显示会经历多次变化：

```
初始：0 today, 0 this month
  ↓
错误：5 today, 10 this month  ← Free 层级的限制 ❌
  ↓
正确：10 today, 50 this month  ← Basic 层级的限制 ✅
```

**用户体验**：
- ❌ 显示闪烁，不专业
- ❌ 用户看到错误的限制数值
- ❌ 可能导致用户困惑

---

## 🔍 根本原因分析

### 数据加载时间线

```
时间 0ms：页面加载
  ↓
subscription: null ← 初始状态
usageData: null
  ↓
getUserTier() 返回 "free" ← ❌ 默认值错误
  ↓
显示：5 today, 10 this month（free 的限制）
  
时间 1000ms：API 完成
  ↓
subscription: { tier: "basic" } ✅
usageData: { daily: 0, monthly: 0 }
  ↓
getUserTier() 返回 "basic" ✅
  ↓
显示：10 today, 50 this month（basic 的限制）✅
```

### 问题代码

```typescript
// hooks/use-usage-limit-v2.ts
const getUserTier = (): UserTier => {
  if (!isAuthenticated) {
    return "anonymous"
  }
  
  // ❌ 问题：subscription 加载中时，返回 "free"
  if (subscription && subscription.tier) {
    return subscription.tier as UserTier
  }
  
  // ❌ 默认为 free（不准确）
  return "free"
}
```

### 影响范围

```typescript
// app/page.tsx
const { remainingDaily, remainingMonthly } = useUsageLimitV2()

// 显示部分
<span>{remainingDaily} today</span>  ← 基于 getUserTier() 计算
<span>{remainingMonthly} this month</span>  ← 基于 getUserTier() 计算
```

---

## 💡 解决方案

### 方案 A：加载时不显示（推荐 ⭐⭐⭐）

**核心思路**：在 subscription 加载完成之前，不显示剩余次数或显示加载状态。

```typescript
// app/page.tsx

// 引入 subscriptionLoading 状态
const { 
  remainingDaily,
  remainingMonthly,
  subscription,
  subscriptionLoading,  // ✅ 新增
} = useUsageLimitV2()

// 显示逻辑
{!isLimitReached && (
  subscriptionLoading ? (
    // ✅ 加载中：显示 Skeleton 或隐藏
    <Skeleton className="h-4 w-32" />
  ) : (
    // ✅ 加载完成：显示正确的值
    <span className="flex items-center gap-1.5">
      <span>{remainingDaily} today</span>
      <span>•</span>
      <span>{remainingMonthly} this month</span>
    </span>
  )
)}
```

**优势**：
- ✅ 无闪烁
- ✅ 显示始终正确
- ✅ 用户体验专业

**劣势**：
- ⚠️ 加载时短暂看不到数值（约 1 秒）

---

### 方案 B：缓存上次的层级（推荐 ⭐⭐）

**核心思路**：将用户层级缓存到 localStorage，初始时使用缓存值。

```typescript
// hooks/use-usage-limit-v2.ts

// 缓存层级到 localStorage
const TIER_STORAGE_KEY = "lumi_user_tier"

const getUserTier = (): UserTier => {
  if (!isAuthenticated) {
    return "anonymous"
  }
  
  // 从 subscription 获取
  if (subscription && subscription.tier) {
    const tier = subscription.tier as UserTier
    // ✅ 缓存到 localStorage
    if (typeof window !== "undefined") {
      localStorage.setItem(TIER_STORAGE_KEY, tier)
    }
    return tier
  }
  
  // ✅ 从 localStorage 读取上次的层级
  if (typeof window !== "undefined") {
    const cachedTier = localStorage.getItem(TIER_STORAGE_KEY)
    if (cachedTier && ['free', 'basic', 'pro'].includes(cachedTier)) {
      return cachedTier as UserTier
    }
  }
  
  // 最后才默认为 free
  return "free"
}
```

**优势**：
- ✅ 初始显示准确（基于缓存）
- ✅ 无闪烁
- ✅ API 完成后验证并更新

**劣势**：
- ⚠️ 如果用户降级，可能短暂显示旧层级
- ⚠️ 需要额外的 localStorage 管理

---

### 方案 C：延迟渲染（推荐 ⭐）

**核心思路**：等待 subscription 加载完成后再渲染整个组件。

```typescript
// app/page.tsx

const { subscription, subscriptionLoading } = useUsageLimitV2()

if (isAuthenticated && subscriptionLoading) {
  // ✅ 显示加载界面
  return (
    <main className="min-h-screen flex items-center justify-center">
      <Loader2 className="w-8 h-8 animate-spin text-primary" />
    </main>
  )
}

// ✅ subscription 已加载，正常显示
return (
  <main>
    {/* 显示正确的限制 */}
    <span>{remainingDaily} today, {remainingMonthly} this month</span>
  </main>
)
```

**优势**：
- ✅ 无闪烁
- ✅ 显示始终正确
- ✅ 实现简单

**劣势**：
- ⚠️ 页面加载略慢（等待 API）

---

## 🎯 推荐实施方案

### 综合方案：A + B（最佳）

**结合方案 A 和 B 的优点**：

1. **使用缓存层级**（减少闪烁）
2. **加载时显示 Skeleton**（专业体验）
3. **加载完成后显示准确值**（可靠）

```typescript
// hooks/use-usage-limit-v2.ts

const TIER_STORAGE_KEY = "lumi_user_tier"

const getUserTier = (): UserTier => {
  if (!isAuthenticated) {
    return "anonymous"
  }
  
  // 优先从 subscription 获取
  if (subscription && subscription.tier) {
    const tier = subscription.tier as UserTier
    // 缓存到 localStorage
    if (typeof window !== "undefined") {
      localStorage.setItem(TIER_STORAGE_KEY, tier)
    }
    return tier
  }
  
  // ✅ 加载中：从缓存读取
  if (subscriptionLoading && typeof window !== "undefined") {
    const cachedTier = localStorage.getItem(TIER_STORAGE_KEY)
    if (cachedTier && ['free', 'basic', 'pro'].includes(cachedTier)) {
      return cachedTier as UserTier
    }
  }
  
  // 最后才默认为 free
  return "free"
}
```

```typescript
// app/page.tsx

{!isLimitReached && (
  <span className="text-xs text-muted-foreground">
    {subscriptionLoading && !subscription ? (
      // ✅ 首次加载：显示 Skeleton
      <Skeleton className="h-4 w-32" />
    ) : (
      // ✅ 加载完成：显示正确的值
      <span className="flex items-center gap-1.5">
        <span>{remainingDaily} today</span>
        <span>•</span>
        <span>{remainingMonthly} this month</span>
      </span>
    )}
  </span>
)}
```

---

## 📊 效果对比

### 修复前（有闪烁）

```
0ms: 显示 "0 today, 0 this month"
100ms: 显示 "5 today, 10 this month"  ← 错误（free 层级）
1000ms: 显示 "10 today, 50 this month"  ← 正确（basic 层级）

用户看到：3 次变化，体验差 ❌
```

### 修复后（方案 A）

```
0ms: 显示 Skeleton（加载中）
1000ms: 显示 "10 today, 50 this month"  ← 直接显示正确值

用户看到：1 次变化，体验好 ✅
```

### 修复后（方案 B）

```
0ms: 显示 "10 today, 50 this month"  ← 使用缓存（通常正确）
1000ms: 验证并更新（如有变化）

用户看到：几乎无变化，体验最好 ✅
```

### 修复后（方案 A + B）

```
首次登录：
0ms: 显示 Skeleton（无缓存）
1000ms: 显示 "10 today, 50 this month"  ← 正确

再次访问：
0ms: 显示 "10 today, 50 this month"  ← 使用缓存
1000ms: 验证（无变化）

用户看到：首次有 Skeleton，之后立即显示 ✅
```

---

## ✅ 推荐方案

**立即实施：方案 A（加载时显示 Skeleton）**

**优势**：
- ✅ 实现简单（5 分钟）
- ✅ 无闪烁
- ✅ 专业体验

**中期实施：方案 A + B（缓存 + Skeleton）**

**优势**：
- ✅ 首次加载有 Skeleton
- ✅ 后续访问立即显示
- ✅ 最佳用户体验

---

## 🎯 实施建议

需要我帮您立即实施**方案 A（显示 Skeleton）**吗？

只需修改 `app/page.tsx`，5 分钟完成，立即消除闪烁问题！


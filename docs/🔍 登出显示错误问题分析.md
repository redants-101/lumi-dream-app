# 🔍 登出显示错误问题分析

## 🚨 问题重现

**用户操作**：
1. Basic 用户在 Dashboard 登出
2. 自动跳转到 Pricing 或 Home
3. 观察显示：10 today, 50 this month ❌ 错误（basic 限制）
4. 应该显示：2 today, 4 this month ✅ 正确（anonymous 限制）

---

## 🔍 问题根源分析

### getUserTier() 的逻辑流程

```typescript
const getUserTier = useCallback((): UserTier => {
  // 1️⃣ 检查是否登录
  if (!isAuthenticated) {
    return "anonymous"  // ✅ 未登录应该走这里
  }
  
  // 2️⃣ 检查 subscription
  if (subscription && subscription.tier) {
    localStorage.setItem(TIER_STORAGE_KEY, tier)  // 缓存
    return tier
  }
  
  // 3️⃣ 加载中：读取缓存
  if (subscriptionLoading && typeof window !== "undefined") {
    const cachedTier = localStorage.getItem(TIER_STORAGE_KEY)
    if (cachedTier && ['free', 'basic', 'pro'].includes(cachedTier)) {
      return cachedTier  // ⚠️ 返回缓存值
    }
  }
  
  // 4️⃣ 默认
  return "free"
}, [isAuthenticated, subscription, subscriptionLoading])
```

### 问题场景推演

#### 场景 A：正常情况（应该工作）

```
登出操作：
  ↓
isAuthenticated: true → false ✅
  ↓
getUserTier() 调用：
  ├─ if (!isAuthenticated) → true ✅
  └─ return "anonymous" ✅
  ↓
显示："2 today, 4 this month" ✅ 正确
```

**这个逻辑应该是对的！**

---

#### 场景 B：useMemo 缓存问题（可能原因）

```
登出前：
  userTier = useMemo(() => getUserTier(), [getUserTier])
  ↓
  getUserTier 依赖：[isAuthenticated, subscription, subscriptionLoading]
  ↓
  userTier 缓存值："basic"

登出时：
  isAuthenticated: true → false
  subscription: {...} → null
  ↓
  getUserTier 重新创建（依赖项变化）✅
  ↓
  但 userTier 的 useMemo 需要等到下次渲染才重新计算 ⚠️
  ↓
  在重新计算前，userTier 还是 "basic" ❌
  ↓
  页面显示：10/50（basic 的限制）❌
```

**这是时序问题！**

---

#### 场景 C：React 批量更新（最可能）

```
登出的 useEffect 执行：
  ├─ setSubscription(null)
  ├─ setUsageData(null)  
  ├─ setIsLimitReached(false)
  ├─ setSubscriptionLoading(false)
  ├─ setInitialized(false)
  └─ localStorage.removeItem(...)

React 批量更新（Batching）：
  ↓
  在下一次渲染前，所有 setState 都不生效
  ↓
  getUserTier() 在这期间被调用（useMemo 计算）
  ↓
  此时 subscription 可能还是旧值 ❌
  ↓
  返回 "basic" ❌
```

---

## 🔧 解决方案

### 方案 1：立即清除 localStorage（在 setState 之前）

```typescript
useEffect(() => {
  if (!isAuthenticated && initialized) {
    console.log("[Usage Limit Context] 🔄 User logged out, resetting state...")
    
    // ✅ 1. 先清除 localStorage（立即生效）
    if (typeof window !== "undefined") {
      try {
        localStorage.removeItem(TIER_STORAGE_KEY)
        localStorage.removeItem(STORAGE_KEY)
        console.log("[Usage Limit Context] 🗑️ Cleared all cached data")
      } catch (error) {
        console.error("[Usage Limit Context] Failed to clear cache:", error)
      }
    }
    
    // ✅ 2. 再重置状态
    setSubscription(null)
    setUsageData(null)
    setIsLimitReached(false)
    setSubscriptionLoading(false)
    setInitialized(false)
  }
}, [isAuthenticated, user, initialized, fetchUserInfo])
```

**效果**：
- localStorage 立即清除
- getUserTier() 读不到缓存
- 即使 subscription 还是旧值，也不会用

---

### 方案 2：getUserTier 不读缓存（当未登录时）

当前逻辑已经正确：
```typescript
if (!isAuthenticated) {
  return "anonymous"  // ✅ 未登录直接返回，不检查缓存
}
```

**这部分是对的！**

---

### 方案 3：检查 useMemo 的依赖

```typescript
// 当前代码
const userTier = useMemo(() => getUserTier(), [getUserTier])
```

**问题**：
- `getUserTier` 是 useCallback，依赖 [isAuthenticated, subscription, subscriptionLoading]
- 当这些变化时，getUserTier 会重新创建
- 但 useMemo 的重新计算依赖于 getUserTier 的引用变化
- 可能有微小的延迟

**更好的方式**：
```typescript
// ✅ 直接依赖原始值
const userTier = useMemo(() => {
  if (!isAuthenticated) return "anonymous"
  if (subscription && subscription.tier) return subscription.tier
  // ...
}, [isAuthenticated, subscription, subscriptionLoading])
```

---

## 🎯 推荐修复

立即实施方案 1 + 3 的组合。


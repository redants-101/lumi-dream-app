# 🐛 支付完成后订阅状态未更新问题分析

## 📋 问题描述

**现象**: 用户完成 Basic 套餐支付后，跳转到 `/dashboard` 页面仍显示为 `free` 用户。

**期望**: 支付完成后，dashboard 应显示为 `basic` 或 `pro` 用户，并显示相应的订阅信息。

---

## 🔍 问题根因分析

### 1. 支付流程回顾

```
用户点击订阅按钮
    ↓
前端调用 /api/checkout/create-session
    ↓
创建 Creem 结账会话（传递 metadata）
    ↓
用户在 Creem 完成支付
    ↓
Creem 发送 Webhook → /api/webhooks/creem
    ↓
Webhook 更新数据库 user_subscriptions 表
    ↓
用户重定向到 /pricing/success
    ↓
用户点击"查看我的订阅" → /dashboard
    ↓
Dashboard 调用 /api/subscription/manage (GET)
    ↓
查询 user_subscriptions 表
```

### 2. 可能的问题点

#### ⚠️ 问题 1: Webhook 未正确配置或未触发

**症状**:
- Creem 后台没有 webhook 发送记录
- 或 webhook 返回 4xx/5xx 错误

**原因**:
1. Webhook URL 配置错误（生产环境 vs 本地开发）
2. Webhook 签名验证失败
3. Creem 产品未正确配置为订阅类型

**排查**:
```bash
# 查看 Creem 后台 Webhook 日志
1. 登录 Creem Dashboard
2. Settings → Webhooks
3. 查看最近的 webhook 事件
4. 检查状态码和响应内容
```

---

#### ⚠️ 问题 2: Metadata 中 user_id 未正确传递

**症状**:
- Webhook 日志显示 `No user_id in metadata`
- 数据库无新记录

**当前代码**:
```typescript:app/api/checkout/create-session/route.ts
const session = await creemClient.createCheckoutSession({
  product_id: productId,
  success_url: CREEM_CONFIG.successUrl,
  metadata: {
    user_id: user?.id || "",           // ⚠️ 如果 user 为 null，这里是空字符串
    user_email: user?.email || "",
    tier,
    billing_cycle: billingCycle,
  },
})
```

**问题**:
- 如果用户**未登录**或**登录状态失效**，`user?.id` 为空
- 空的 `user_id` 会导致 webhook 无法关联到正确的用户

**解决方案**:
```typescript
// ✅ 修改后：强制要求登录
if (!user) {
  return Response.json(
    { error: "Please sign in to subscribe" },
    { status: 401 }
  )
}

const session = await creemClient.createCheckoutSession({
  product_id: productId,
  success_url: CREEM_CONFIG.successUrl,
  metadata: {
    user_id: user.id,      // 现在保证有值
    user_email: user.email,
    tier,
    billing_cycle: billingCycle,
  },
})
```

---

#### ⚠️ 问题 3: 数据库 RLS 策略阻止写入

**症状**:
- Webhook 返回 500 错误
- 日志显示 `Failed to update subscription: new row violates row-level security policy`

**当前数据库策略**:
```sql:docs/3.定价支付/Creem数据库Schema.sql
-- 策略 3: 服务端可以插入订阅记录（通过 service role）
CREATE POLICY "Service can insert subscriptions"
  ON user_subscriptions
  FOR INSERT
  WITH CHECK (true);

-- 策略 4: 服务端可以更新订阅记录（Webhook 使用）
CREATE POLICY "Service can update subscriptions"
  ON user_subscriptions
  FOR UPDATE
  USING (true);
```

**问题**:
- 策略看起来正确，但**必须使用 service_role key**
- 如果使用普通的 anon key，策略会阻止写入

**排查**:
```typescript
// 检查 lib/supabase/server.ts
// 确保使用 service_role key
import { createClient } from '@supabase/supabase-js'

export const createClient = () => {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,  // ✅ 必须使用 service role key
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }
  )
}
```

---

#### ⚠️ 问题 4: 数据库缺少 creem_product_id 字段

**症状**:
- Webhook 执行成功，但数据不完整
- 无法追踪具体的产品购买记录

**当前 Schema**:
```sql:docs/3.定价支付/Creem数据库Schema.sql
CREATE TABLE IF NOT EXISTS user_subscriptions (
  -- ...
  creem_subscription_id TEXT UNIQUE,
  creem_customer_email TEXT,
  creem_product_id TEXT,              -- ✅ 已经有这个字段
  -- ...
);
```

**检查**:
```sql
-- 在 Supabase SQL Editor 中运行
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'user_subscriptions';
```

**如果缺少该字段**:
```sql
ALTER TABLE user_subscriptions 
ADD COLUMN creem_product_id TEXT;
```

---

#### ⚠️ 问题 5: Webhook 处理完成前用户就访问 Dashboard

**症状**:
- 第一次访问 dashboard 显示 free
- 刷新页面后显示正确的套餐

**原因**:
- 支付完成后立即重定向到 `/pricing/success`
- 此时 Creem webhook 可能还未处理完成
- 用户点击"查看订阅"时，数据库尚未更新

**时间线**:
```
T0: 用户完成支付
T0+100ms: Creem 重定向到 /pricing/success
T0+500ms: 用户点击"查看我的订阅"
T0+800ms: Dashboard 查询数据库（订阅未激活 ❌）
T0+1200ms: Webhook 处理完成，数据库更新 ✅
```

**解决方案**:

方案 A: **在 success 页面轮询验证订阅状态**（推荐）

```typescript
// app/pricing/success/page.tsx
useEffect(() => {
  let attempts = 0
  const maxAttempts = 10 // 最多轮询 10 次
  
  const checkSubscription = async () => {
    try {
      const response = await fetch("/api/subscription/manage")
      const data = await response.json()
      
      if (data.tier !== "free") {
        // ✅ 订阅已激活
        setLoading(false)
        return true
      }
      
      // 订阅未激活，继续等待
      attempts++
      if (attempts < maxAttempts) {
        setTimeout(checkSubscription, 1000) // 1秒后重试
      } else {
        // 超时，但仍可能成功（webhook 延迟）
        setLoading(false)
      }
    } catch (error) {
      console.error("Failed to check subscription:", error)
      setLoading(false)
    }
  }
  
  // 延迟 2 秒后开始检查（给 webhook 处理时间）
  setTimeout(checkSubscription, 2000)
}, [])
```

方案 B: **Webhook 完成后通过 SSE 或 WebSocket 通知前端**（高级）

---

#### ⚠️ 问题 6: Webhook 中 product_id 未正确存储

**当前 Webhook 代码**:
```typescript:app/api/webhooks/creem/route.ts
const { error } = await supabase.from("user_subscriptions").upsert(
  {
    user_id: userId,
    tier: tierInfo.tier,
    billing_cycle: tierInfo.billingCycle,
    status: "active",
    creem_subscription_id: subscription_id,
    creem_customer_email: customer_email,
    // ⚠️ 缺少 creem_product_id 字段
    current_period_start: new Date().toISOString(),
    current_period_end: new Date(
      Date.now() +
        (tierInfo.billingCycle === "yearly" ? 365 : 30) * 24 * 60 * 60 * 1000
    ).toISOString(),
    updated_at: new Date().toISOString(),
  },
  {
    onConflict: "user_id",
  }
)
```

**修复**:
```typescript
const { error } = await supabase.from("user_subscriptions").upsert(
  {
    user_id: userId,
    tier: tierInfo.tier,
    billing_cycle: tierInfo.billingCycle,
    status: "active",
    creem_subscription_id: subscription_id,
    creem_customer_email: customer_email,
    creem_product_id: product_id,  // ✅ 添加这一行
    current_period_start: new Date().toISOString(),
    current_period_end: new Date(
      Date.now() +
        (tierInfo.billingCycle === "yearly" ? 365 : 30) * 24 * 60 * 60 * 1000
    ).toISOString(),
    updated_at: new Date().toISOString(),
  },
  {
    onConflict: "user_id",
  }
)
```

---

## 📊 应该存入数据库的完整字段

### 必须字段（当前已有）

| 字段名 | 类型 | 说明 | 示例值 |
|--------|------|------|--------|
| `id` | UUID | 主键 | `550e8400-e29b-41d4-a716-446655440000` |
| `user_id` | UUID | 用户 ID（外键） | `123e4567-e89b-12d3-a456-426614174000` |
| `tier` | TEXT | 订阅层级 | `"basic"` / `"pro"` / `"free"` |
| `billing_cycle` | TEXT | 计费周期 | `"monthly"` / `"yearly"` |
| `status` | TEXT | 订阅状态 | `"active"` / `"canceled"` / `"expired"` |

### Creem 相关字段（当前已有）

| 字段名 | 类型 | 说明 | 来源 |
|--------|------|------|------|
| `creem_subscription_id` | TEXT | Creem 订阅 ID | Webhook `data.subscription_id` |
| `creem_customer_email` | TEXT | 客户邮箱 | Webhook `data.customer_email` |
| `creem_product_id` | TEXT | 产品 ID | Webhook `data.product_id` ⚠️ 需添加 |

### 时间戳字段（当前已有）

| 字段名 | 类型 | 说明 | 计算方式 |
|--------|------|------|----------|
| `current_period_start` | TIMESTAMPTZ | 当前周期开始 | `new Date().toISOString()` |
| `current_period_end` | TIMESTAMPTZ | 当前周期结束 | 开始时间 + 30天（月付）或 365天（年付） |
| `canceled_at` | TIMESTAMPTZ | 取消时间 | 用户取消时设置 |
| `created_at` | TIMESTAMPTZ | 创建时间 | 默认 `NOW()` |
| `updated_at` | TIMESTAMPTZ | 更新时间 | 默认 `NOW()`，触发器自动更新 |

### 可选字段（推荐添加）

| 字段名 | 类型 | 说明 | 用途 |
|--------|------|------|------|
| `metadata` | JSONB | 额外元数据 | 存储 Creem 返回的其他信息 |
| `trial_end` | TIMESTAMPTZ | 试用结束时间 | 如果有试用期 |
| `discount_code` | TEXT | 折扣码 | 如果使用了优惠券 |
| `amount_paid` | NUMERIC | 实际支付金额 | 用于财务对账 |
| `currency` | TEXT | 货币类型 | `"USD"` |

---

## ✅ 完整的 Webhook 处理逻辑

### 推荐的 upsert 语句

```typescript
// app/api/webhooks/creem/route.ts

async function handleCheckoutCompleted(data: any) {
  console.log("[Webhook] Checkout completed:", data.id)

  const { 
    customer_email, 
    product_id, 
    metadata, 
    subscription_id,
    amount_paid,      // 新增：支付金额
    currency,         // 新增：货币
  } = data

  // 解析套餐信息
  const tierInfo = parseTierFromProductId(product_id)
  if (!tierInfo) {
    console.error("[Webhook] Unknown product ID:", product_id)
    return
  }

  // 获取用户 ID（优先从 metadata）
  const userId = metadata?.user_id
  
  if (!userId) {
    console.error("[Webhook] No user_id in metadata")
    console.error("[Webhook] Data:", JSON.stringify(data, null, 2))
    return
  }
  
  console.log("[Webhook] Processing for user:", userId)
  console.log("[Webhook] Tier:", tierInfo.tier)
  console.log("[Webhook] Billing cycle:", tierInfo.billingCycle)
  
  const supabase = await createClient()

  // 计算周期结束时间
  const periodStart = new Date()
  const periodEnd = new Date(
    periodStart.getTime() + 
    (tierInfo.billingCycle === "yearly" ? 365 : 30) * 24 * 60 * 60 * 1000
  )

  // ✅ 完整的 upsert 语句
  const { data: result, error } = await supabase
    .from("user_subscriptions")
    .upsert(
      {
        user_id: userId,
        tier: tierInfo.tier,
        billing_cycle: tierInfo.billingCycle,
        status: "active",
        
        // Creem 相关信息
        creem_subscription_id: subscription_id,
        creem_customer_email: customer_email,
        creem_product_id: product_id,  // ✅ 添加产品 ID
        
        // 时间戳
        current_period_start: periodStart.toISOString(),
        current_period_end: periodEnd.toISOString(),
        updated_at: new Date().toISOString(),
        
        // 可选：支付信息
        metadata: {
          amount_paid: amount_paid || 0,
          currency: currency || "USD",
          checkout_id: data.id,
          activated_at: new Date().toISOString(),
        },
      },
      {
        onConflict: "user_id",
      }
    )
    .select() // ✅ 返回插入的数据，用于验证

  if (error) {
    console.error("[Webhook] Failed to update subscription:", error)
    console.error("[Webhook] Error details:", JSON.stringify(error, null, 2))
    return
  }

  console.log("[Webhook] ✅ Subscription activated successfully")
  console.log("[Webhook] Data:", JSON.stringify(result, null, 2))
}
```

---

## 🔧 调试步骤

### 步骤 1: 检查 Webhook 是否触发

```bash
# 1. 查看 Creem 后台
Creem Dashboard → Settings → Webhooks → Events

# 2. 查看服务器日志
# Vercel: https://vercel.com/[你的项目]/deployments
# 或本地: 查看终端输出

# 3. 确认 Webhook URL 正确
生产环境: https://www.lumidreams.app/api/webhooks/creem
开发环境: https://[ngrok-url]/api/webhooks/creem
```

### 步骤 2: 检查数据库记录

```sql
-- 在 Supabase SQL Editor 中运行

-- 查看所有订阅记录
SELECT * FROM user_subscriptions;

-- 查看特定用户的订阅
SELECT * FROM user_subscriptions 
WHERE user_id = 'YOUR_USER_ID';

-- 查看最近创建的订阅
SELECT * FROM user_subscriptions 
ORDER BY created_at DESC 
LIMIT 10;
```

### 步骤 3: 手动测试 Webhook

```bash
# 使用 curl 模拟 Webhook 请求
curl -X POST https://www.lumidreams.app/api/webhooks/creem \
  -H "Content-Type: application/json" \
  -H "x-creem-signature: YOUR_SIGNATURE" \
  -d '{
    "type": "checkout.session.completed",
    "data": {
      "id": "cs_test_123",
      "customer_email": "test@example.com",
      "product_id": "YOUR_PRODUCT_ID",
      "subscription_id": "sub_test_123",
      "metadata": {
        "user_id": "YOUR_USER_ID",
        "tier": "basic",
        "billing_cycle": "monthly"
      }
    }
  }'
```

### 步骤 4: 验证用户登录状态

```typescript
// 在 /api/checkout/create-session 添加日志
console.log("User logged in:", !!user)
console.log("User ID:", user?.id)
console.log("User Email:", user?.email)
```

---

## 📝 完整修复清单

### 1. 修复 checkout API（强制登录）

```typescript
// app/api/checkout/create-session/route.ts

export async function POST(request: NextRequest) {
  // ... 验证参数 ...

  // ✅ 获取当前用户（必须登录）
  const supabase = await createClient()
  const {
    data: { user },
  } = await supabase.auth.getUser()
  
  // ✅ 强制要求登录
  if (!user) {
    console.error("❌ [Checkout] User not authenticated")
    return Response.json(
      { error: "Please sign in to subscribe" },
      { status: 401 }
    )
  }
  
  console.log("✅ [Checkout] User authenticated:", user.email)
  
  // ... 其余代码 ...
}
```

### 2. 修复 Webhook 处理（添加 product_id）

```typescript
// app/api/webhooks/creem/route.ts

const { error } = await supabase.from("user_subscriptions").upsert(
  {
    user_id: userId,
    tier: tierInfo.tier,
    billing_cycle: tierInfo.billingCycle,
    status: "active",
    creem_subscription_id: subscription_id,
    creem_customer_email: customer_email,
    creem_product_id: product_id,  // ✅ 添加这一行
    current_period_start: new Date().toISOString(),
    current_period_end: new Date(
      Date.now() +
        (tierInfo.billingCycle === "yearly" ? 365 : 30) * 24 * 60 * 60 * 1000
    ).toISOString(),
    updated_at: new Date().toISOString(),
  },
  {
    onConflict: "user_id",
  }
)
.select() // ✅ 返回结果用于调试

// ✅ 添加详细日志
if (error) {
  console.error("[Webhook] ❌ Failed to update subscription")
  console.error("[Webhook] Error:", JSON.stringify(error, null, 2))
  console.error("[Webhook] User ID:", userId)
  console.error("[Webhook] Tier:", tierInfo.tier)
  return
}

console.log("[Webhook] ✅ Subscription updated successfully")
```

### 3. 修复 Success 页面（轮询验证）

```typescript
// app/pricing/success/page.tsx

"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { CheckCircle, Loader2, XCircle } from "lucide-react"
import confetti from "canvas-confetti"
import { toast } from "sonner"

export default function PaymentSuccessPage() {
  const router = useRouter()
  const [loading, setLoading] = useState(true)
  const [subscriptionTier, setSubscriptionTier] = useState<string | null>(null)
  const [verificationFailed, setVerificationFailed] = useState(false)

  useEffect(() => {
    // 触发庆祝动画
    const duration = 3 * 1000
    const animationEnd = Date.now() + duration

    const interval = setInterval(() => {
      const timeLeft = animationEnd - Date.now()

      if (timeLeft <= 0) {
        clearInterval(interval)
        return
      }

      confetti({
        particleCount: 2,
        angle: 60,
        spread: 55,
        origin: { x: 0 },
        colors: ["#a855f7", "#ec4899", "#f59e0b"],
      })
      confetti({
        particleCount: 2,
        angle: 120,
        spread: 55,
        origin: { x: 1 },
        colors: ["#a855f7", "#ec4899", "#f59e0b"],
      })
    }, 30)

    return () => clearInterval(interval)
  }, [])

  useEffect(() => {
    // ✅ 轮询验证订阅状态
    let attempts = 0
    const maxAttempts = 10 // 最多轮询 10 次（10 秒）
    
    const checkSubscription = async () => {
      try {
        console.log(`[Success] Checking subscription (attempt ${attempts + 1}/${maxAttempts})`)
        
        const response = await fetch("/api/subscription/manage")
        
        if (!response.ok) {
          throw new Error("Failed to fetch subscription")
        }
        
        const data = await response.json()
        console.log("[Success] Subscription data:", data)
        
        if (data.tier !== "free") {
          // ✅ 订阅已激活
          console.log("[Success] ✅ Subscription activated:", data.tier)
          setSubscriptionTier(data.tier)
          setLoading(false)
          toast.success("Subscription activated successfully!")
          return
        }
        
        // 订阅未激活，继续等待
        attempts++
        if (attempts < maxAttempts) {
          console.log("[Success] Subscription not ready, retrying in 1s...")
          setTimeout(checkSubscription, 1000) // 1秒后重试
        } else {
          // ⚠️ 超时，但可能是 webhook 延迟
          console.warn("[Success] ⚠️ Verification timeout, but subscription might still activate")
          setLoading(false)
          setVerificationFailed(true)
          toast.warning("Subscription verification is taking longer than expected. Please check your dashboard.")
        }
      } catch (error) {
        console.error("[Success] Error checking subscription:", error)
        attempts++
        if (attempts < maxAttempts) {
          setTimeout(checkSubscription, 1000)
        } else {
          setLoading(false)
          setVerificationFailed(true)
          toast.error("Failed to verify subscription. Please check your dashboard.")
        }
      }
    }
    
    // 延迟 2 秒后开始检查（给 webhook 处理时间）
    setTimeout(checkSubscription, 2000)
  }, [])

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted/20 flex items-center justify-center p-4">
      <Card className="max-w-md w-full text-center glow-box">
        <CardHeader className="pb-4">
          {loading ? (
            <div className="flex justify-center mb-4">
              <Loader2 className="w-16 h-16 text-primary animate-spin" />
            </div>
          ) : verificationFailed ? (
            <div className="flex justify-center mb-4">
              <XCircle className="w-16 h-16 text-yellow-500" />
            </div>
          ) : (
            <div className="flex justify-center mb-4">
              <CheckCircle className="w-16 h-16 text-green-500" />
            </div>
          )}
          
          <CardTitle className="text-3xl">
            {loading 
              ? "Activating..." 
              : verificationFailed 
                ? "Payment Received" 
                : "Payment Successful!"}
          </CardTitle>
          
          <CardDescription className="text-base mt-2">
            {loading
              ? "We're activating your subscription..."
              : verificationFailed
                ? "Your payment is being processed. It may take a few minutes to activate."
                : `Your ${subscriptionTier?.toUpperCase()} subscription is now active!`}
          </CardDescription>
        </CardHeader>

        <CardContent className="space-y-4">
          {!loading && (
            <>
              <div className="bg-muted rounded-lg p-4 text-sm text-left space-y-2">
                {verificationFailed ? (
                  <>
                    <p>✅ Payment completed</p>
                    <p>⏳ Activation in progress</p>
                    <p>📧 You'll receive a confirmation email</p>
                  </>
                ) : (
                  <>
                    <p>✨ Subscription activated</p>
                    <p>📧 Confirmation email sent</p>
                    <p>🎉 Premium features unlocked</p>
                  </>
                )}
              </div>

              <div className="flex flex-col gap-2">
                <Button
                  onClick={() => router.push("/")}
                  size="lg"
                  className="w-full"
                >
                  Start Interpreting Dreams
                </Button>
                
                <Button
                  onClick={() => router.push("/dashboard")}
                  variant="outline"
                  size="lg"
                  className="w-full"
                >
                  View My Subscription
                </Button>
              </div>
            </>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

### 4. 检查数据库字段是否完整

```sql
-- 在 Supabase SQL Editor 中运行

-- 检查表结构
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'user_subscriptions'
ORDER BY ordinal_position;

-- 如果缺少 creem_product_id 字段，添加它
ALTER TABLE user_subscriptions 
ADD COLUMN IF NOT EXISTS creem_product_id TEXT;

-- 验证 RLS 策略
SELECT * FROM pg_policies WHERE tablename = 'user_subscriptions';
```

### 5. 验证 Supabase Service Role Key

```bash
# 检查 .env.local 文件
SUPABASE_SERVICE_ROLE_KEY=eyJ...  # 必须是 service_role key，不是 anon key
```

```typescript
// lib/supabase/server.ts

import { createClient as createSupabaseClient } from '@supabase/supabase-js'

export async function createClient() {
  return createSupabaseClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,  // ✅ 必须使用 service_role
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }
  )
}
```

---

## 📊 数据库字段总结

### 最终的 user_subscriptions 表结构

```sql
CREATE TABLE user_subscriptions (
  -- 主键和外键
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  
  -- 订阅信息
  tier TEXT NOT NULL DEFAULT 'free' CHECK (tier IN ('free', 'basic', 'pro')),
  billing_cycle TEXT CHECK (billing_cycle IN ('monthly', 'yearly')),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'canceled', 'expired', 'past_due')),
  
  -- Creem 相关信息（必须字段）
  creem_subscription_id TEXT UNIQUE,
  creem_customer_email TEXT,
  creem_product_id TEXT,              -- ✅ 必须存储
  
  -- 时间戳（必须字段）
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  canceled_at TIMESTAMPTZ,
  
  -- 元数据（可选但推荐）
  metadata JSONB DEFAULT '{}'::jsonb,
  
  -- 审计字段
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 必须存储的字段（优先级：高）

- ✅ `user_id` - 关联用户
- ✅ `tier` - 订阅层级
- ✅ `billing_cycle` - 计费周期
- ✅ `status` - 订阅状态
- ✅ `creem_subscription_id` - Creem 订阅 ID（用于取消订阅）
- ✅ `creem_product_id` - Creem 产品 ID（用于追踪）
- ✅ `current_period_end` - 周期结束时间（用于判断是否过期）

### 推荐存储的字段（优先级：中）

- ✅ `creem_customer_email` - 客户邮箱（用于对账）
- ✅ `current_period_start` - 周期开始时间
- ✅ `metadata` - 额外信息（JSON 格式，灵活）

### 可选字段（优先级：低）

- `canceled_at` - 取消时间
- `trial_end` - 试用结束时间
- `discount_code` - 折扣码

---

## 🎯 快速修复步骤

1. **修复 checkout API**（5 分钟）
   - 添加登录检查
   - 确保 `user_id` 不为空

2. **修复 Webhook**（5 分钟）
   - 添加 `creem_product_id` 字段
   - 添加详细日志
   - 使用 `.select()` 返回结果

3. **修复 Success 页面**（10 分钟）
   - 添加轮询逻辑
   - 验证订阅状态
   - 改善用户体验

4. **验证数据库**（3 分钟）
   - 检查表结构
   - 确认 RLS 策略
   - 验证 service role key

5. **测试完整流程**（10 分钟）
   - 完成一次测试支付
   - 查看 webhook 日志
   - 验证数据库记录
   - 访问 dashboard

**总时间**: 约 30-40 分钟

---

**文档版本**: v1.0  
**创建日期**: 2025-10-28  
**状态**: 🔧 待修复

